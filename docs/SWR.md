# Stale‑While‑Revalidate (SWR) в проекте

Цели:
- Мгновенно отдавать кэшированные данные в UI
- Обновлять данные в фоне без мерцаний
- Исключить дублирующиеся параллельные запросы
- Единый подход во всех сторах

## Как это работает

`src/lib/swrCache.ts` содержит две утилиты:
- `shouldRevalidate(fetchedAt, ttlMs)` — решает, пора ли фонового обновления. Проверка выполняется **только в момент вызова метода стора**, поэтому нужен повторный вызов (вручную или через таймер).
- `dedupe(key, fetcher)` — дедупликация параллельных запросов по ключу, чтобы при множественных вызовах не плодились одинаковые HTTP-запросы.

Алгоритм в сторах (пример — `useUserStore`):
1. Держим `data`, `fetchedAt` и индикаторы загрузки.
2. При вызове `fetchX({ force, ttlMs })`:
   - Если `data` уже есть — сразу возвращаем её в компонент (никаких спиннеров).
   - Если `force===true` или `shouldRevalidate(...)` вернул `true`, через `dedupe` запускаем фоновой `fetch`.
   - Если данных нет, работаем в «обычном» режиме с `isLoading=true`.

По умолчанию `ttlMs=0`, поэтому **любой** повторный вызов метода при наличии кеша мгновенно отдаст старые данные и тут же инициирует фоновой запрос. Если нужен более редкий рефреш, передавайте `ttlMs` вручную.

Переменные окружения:
- `VITE_DISABLE_CACHE=true` — полностью отключает SWR-путь и всегда ходит в API с индикатором загрузки.
- Других env-переменных для SWR нет — фоновые обновления управляются только повторными вызовами методов стора.

## Примеры

### Профиль пользователя
```ts
const { fetchUserProfile } = useUserStore.getState();
await fetchUserProfile(); // вернет кеш + запустит фон
await fetchUserProfile({ force: true }); // игнорирует кеш
```

### Навыки пользователя
```ts
const { fetchAvailableSkills } = useUserStore.getState();
await fetchAvailableSkills({ ttlMs: 60_000 }); // фон после минутного TTL
```

### Детали аравта
```ts
const { fetchAravtDetails } = useAravtsStore.getState();
await fetchAravtDetails(aravtId); // вернет из кэша или обновит в фоне
```

### Auth-store
```ts
const { fetchUser } = useAuthStore.getState();
await fetchUser(); // отдаст закешированного user и запустит SWR-обновление
await fetchUser({ force: true }); // принудительный запрос профиля
```

## Как проверить, что фон работает

1. Проверьте `.env`: `VITE_DISABLE_CACHE` не должен быть `true`.
2. Откройте `/dashboard/:id`, дождитесь первого ответа (холодный запрос).
3. Перезагрузите страницу или переключитесь на другой ардавт — `useSelectedAravt` снова вызовет `fetchAravtDetails`, который мгновенно отдаст кеш и почти сразу запустит фоновой запрос `/aravt/:id`.
4. Для auth-store достаточно любого визита при наличии токена: `App` вызовет `fetchUser()`, Network покажет один `/users/user/:id`, но UI останется на кешированных данных. Принудительный тест — выполнить `useAuthStore.getState().fetchUser({ force: true })` в DevTools.
5. Чтобы вручную увидеть SWR в других сторах, повторно вызовите `fetchX()` (перейдите на `/profile` дважды или вызовите `fetchUserProfile({ force: true })` в DevTools) — второй вызов отдаст кеш и параллельно отправит запрос.

Если фоновых запросов нет:
- Убедитесь, что кэш не отключён (`VITE_DISABLE_CACHE`).
- Проверьте, что компонент действительно повторно вызывает метод стора (таймер, пользовательское действие, переход между страницами).
- Посмотрите логи в консоли: все SWR-ветки логируют ошибки вида `SWR refresh ... failed`.
